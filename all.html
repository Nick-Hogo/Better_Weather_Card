<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星汉·拟真流体天气海报</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@300;400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #030712;
            color: rgba(255, 255, 255, 0.85);
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        .font-msz { font-family: 'Ma Shan Zheng', cursive; }
        .font-song { font-family: 'Noto Serif SC', serif; font-weight: 700; }

        .glass-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
            backdrop-filter: saturate(120%) blur(2px);
            -webkit-backdrop-filter: saturate(120%) blur(2px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.1),
                        0 0 80px rgba(255, 255, 255, 0.05);
            will-change: filter;
        }

        .card-title {
            font-size: 0.75rem;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.35);
            font-weight: 300;
            text-transform: uppercase;
        }
        
        .location-glow {
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3), 
                         0 0 40px rgba(255, 255, 255, 0.2), 
                         0 0 60px rgba(255, 255, 255, 0.1);
        }
        
        .forecast-divider {
            height: 1px;
            width: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.08) 20%, rgba(255,255,255,0.12) 50%, rgba(255,255,255,0.08) 80%, transparent 100%);
            margin: 0.5rem 0;
        }

        .dock-button {
            transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .dock-button.active {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .dock-button.active svg {
            opacity: 1;
            transform: scale(1.1);
        }

        @media (hover: hover) and (pointer: fine) {
            .dock-button:hover:not(.active) {
                background: rgba(255, 255, 255, 0.05);
            }
            .dock-button:hover:not(.active) svg {
                opacity: 0.8;
            }
        }

        .lantern-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        
        .lantern {
            position: absolute;
            will-change: transform, opacity;
            animation: lanternFloat 8s ease-in-out infinite, lanternGlow 3s ease-in-out infinite;
            filter: drop-shadow(0 0 8px rgba(255,200,80,0.9)) drop-shadow(0 0 16px rgba(255,180,60,0.6));
        }
        
        @keyframes lanternFloat {
            0%, 100% { transform: translateY(0px) translateX(0px); }
            50% { transform: translateY(-5px) translateX(3px); }
        }
        
        @keyframes lanternGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1.0; }
        }
        
        .secondary-text {
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        @media (max-width: 1024px) {
            #main-grid {
                grid-template-columns: 1.2fr 1fr;
                height: auto;
                width: 95vw;
                margin-top: 2rem;
            }
            .hide-on-tablet { display: none; }
        }

        @media (max-width: 768px) {
            body {
                overflow-y: auto;
            }
            #ui-container {
                height: auto;
                padding: 4rem 1rem 8rem 1rem;
            }
            #main-grid {
                display: flex;
                flex-direction: column;
                width: 100%;
            }
            .hide-on-mobile { display: none; }
        }
    </style>
</head>
<body class="w-screen h-screen">

    <canvas id="three-canvas" class="fixed top-0 left-0 w-full h-full outline-none"></canvas>

    <div id="lantern-container" class="lantern-container"></div>

    <main id="ui-container" class="relative w-full h-full flex items-center justify-center p-4 md:p-8 z-10">
        <div id="main-grid" class="grid grid-cols-[1.618fr_1fr] grid-rows-[2fr_1fr] gap-4 md:gap-6 w-full max-w-6xl" style="height: min(85vh, 900px);">

            <div class="glass-card row-span-2 rounded-3xl p-8 flex flex-col justify-between">
                <div class="relative">
                    <div class="card-title">天象 · CELESTIAL</div>
                    <div class="font-song text-5xl md:text-6xl location-glow mt-1">长安</div>
                    <div class="absolute top-0 right-0 text-right">
                        <div id="clock-time" class="text-2xl md:text-3xl font-light">22:08</div>
                        <div id="clock-date" class="text-sm font-light text-white/50 mt-1"></div>
                        <div class="text-sm font-light text-white/50">甲辰年 冬月廿七</div>
                    </div>
                </div>

                <div class="flex flex-col items-start justify-center">
                    <div class="flex items-end gap-2">
                         <span id="temp-value" class="text-8xl md:text-9xl font-light leading-none">6</span>
                         <span class="text-5xl md:text-6xl font-light -mb-2">°C</span>
                    </div>
                    <div id="weather-desc" class="font-msz text-3xl font-light text-white/80 mt-2 flex items-center gap-2">
                        <svg class="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <span>晴空万里</span>
                    </div>
                </div>

                <div class="grid grid-cols-[auto_1fr] items-center gap-6">
                    <div class="flex flex-col items-center justify-center w-20 h-20 rounded-full border border-green-400/50 bg-green-500/10">
                        <div class="text-3xl font-bold text-green-300">32</div>
                        <div class="text-xs text-green-300/60">AQI</div>
                    </div>
                    <div class="grid grid-cols-3 grid-rows-2 gap-x-4 gap-y-3 text-sm secondary-text">
                        <div class="flex flex-col">
                            <span class="text-white/50">气压</span>
                            <span class="font-bold text-base mt-1">1022 <span class="text-xs font-light">hPa</span></span>
                        </div>
                         <div class="flex flex-col">
                            <span class="text-white/50">湿度</span>
                            <span class="font-bold text-base mt-1">45 <span class="text-xs font-light">%</span></span>
                        </div>
                         <div class="flex flex-col">
                            <span class="text-white/50">风速</span>
                            <span class="font-bold text-base mt-1">1.2 <span class="text-xs font-light">m/s</span></span>
                        </div>
                         <div class="flex flex-col">
                            <span class="text-white/50">体感</span>
                            <span class="font-bold text-base mt-1">4 <span class="text-xs font-light">°C</span></span>
                        </div>
                         <div class="flex flex-col">
                            <span class="text-white/50">紫外线</span>
                            <span class="font-bold text-base mt-1">弱</span>
                        </div>
                         <div class="flex flex-col">
                            <span class="text-white/50">能见度</span>
                            <span class="font-bold text-base mt-1">15 <span class="text-xs font-light">km</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="glass-card rounded-3xl p-8 flex flex-col items-center justify-center relative">
                <div class="card-title absolute top-6 left-6">诗意 · POETRY</div>
                <div class="h-full flex items-center justify-center">
                    <p id="poetry-text" class="font-msz text-3xl" style="writing-mode: vertical-rl; text-orientation: mixed;">
                        星汉灿烂，若出其里。
                    </p>
                </div>
            </div>

            <div class="glass-card rounded-3xl p-8 flex flex-col justify-around relative">
                <div class="card-title absolute top-6 left-6">未来 · FORECAST</div>
                <div class="w-full flex flex-col justify-around h-full mt-4 secondary-text">
                    <div class="flex items-center justify-between w-full text-base">
                        <span>明天</span>
                        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" /></svg>
                        <span>多云</span>
                        <span>8° / -2°</span>
                    </div>
                    <div class="forecast-divider"></div>
                    <div class="flex items-center justify-between w-full text-base">
                        <span>周六</span>
                        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                        <span>晴</span>
                        <span>10° / 0°</span>
                    </div>
                    <div class="forecast-divider"></div>
                    <div class="flex items-center justify-between w-full text-base">
                        <span>周日</span>
                        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span>小雪</span>
                        <span>3° / -4°</span>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <footer class="fixed bottom-4 md:bottom-8 left-1/2 -translate-x-1/2 z-20">
        <div class="glass-card flex items-center justify-center gap-2 p-2 rounded-full">
            <button class="dock-button active w-12 h-12 rounded-full flex items-center justify-center" data-mode="0">
                <svg class="w-7 h-7 opacity-60 transition-all duration-150" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            </button>
             <button class="dock-button w-12 h-12 rounded-full flex items-center justify-center" data-mode="1">
                <svg class="w-7 h-7 opacity-60 transition-all duration-150" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" />
                </svg>
            </button>
             <button class="dock-button w-12 h-12 rounded-full flex items-center justify-center" data-mode="2">
                <svg class="w-7 h-7 opacity-60 transition-all duration-150" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>
             <button class="dock-button w-12 h-12 rounded-full flex items-center justify-center" data-mode="3">
                <svg class="w-7 h-7 opacity-60 transition-all duration-150" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
                </svg>
            </button>
        </div>
    </footer>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const MODE_STAR = 0, MODE_RAIN = 1, MODE_SNOW = 2, MODE_WIND = 3;
        const MODE_LERP_MS = 800;
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const STAR_COUNT = isMobile ? 4500 : 9000;
        const RAIN_COUNT = isMobile ? 2000 : 3500;
        const POINTER_SMOOTH = 0.18;

        const weatherData = [
            { temp: 6, desc: '晴空万里', poetry: '星汉灿烂，若出其里。' },
            { temp: 8, desc: '细雨满江', poetry: '沾衣欲湿杏花雨，吹面不寒杨柳风。' },
            { temp: -2, desc: '漫天飞雪', poetry: '晚来天欲雪，能饮一杯无？' },
            { temp: 12, desc: '大风起兮', poetry: '大风起兮云飞扬。' }
        ];

        class PointsEngine {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.count = STAR_COUNT;
                this.uniforms = {
                    uTime: { value: 0 },
                    uMode: { value: 0 },
                    uPointer: { value: new THREE.Vector2(0.5, 0.5) },
                    uViewport: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uInteractionIntensity: { value: 1 }
                };
                this.material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: this.vertexShader(),
                    fragmentShader: this.fragmentShader(),
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                this.geometry = this.createGeometry();
                this.points = new THREE.Points(this.geometry, this.material);
                this.scene.add(this.points);
            }

            createGeometry() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                const speeds = new Float32Array(this.count);
                const randoms = new Float32Array(this.count);
                const spins = new Float32Array(this.count);

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 2000;
                    positions[i3 + 1] = (Math.random() - 0.5) * 1400;
                    positions[i3 + 2] = (Math.random() - 0.5) * 800;

                    sizes[i] = 6 + Math.random() * 8;

                    speeds[i] = 0.4 + Math.random() * 0.6;
                    randoms[i] = Math.random();
                    spins[i] = Math.random() * Math.PI * 2;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
                geometry.setAttribute('randomVal', new THREE.BufferAttribute(randoms, 1));
                geometry.setAttribute('spinPhase', new THREE.BufferAttribute(spins, 1));
                return geometry;
            }

            vertexShader() {
                return `
                    attribute float size;
                    attribute float speed;
                    attribute float randomVal;
                    attribute float spinPhase;
                    uniform float uTime;
                    uniform float uMode;
                    uniform vec2 uPointer;
                    uniform vec2 uViewport;
                    uniform float uInteractionIntensity;
                    varying float vRandom;
                    varying float vStarMask;
                    varying float vSnowMask;
                    varying float vWindMask;
                    varying float vSpinAngle;
                    varying float vSnowFade;

                    void main() {
                        float isStars = smoothstep(0.5, 0.0, uMode);
                        float isSnow = smoothstep(1.3, 1.7, uMode) * smoothstep(2.7, 2.3, uMode);
                        float isWind = smoothstep(2.5, 3.0, uMode);

                        vec3 pos = position;
                        vec2 mouseNdc = (uPointer / uViewport) * 2.0 - 1.0;
                        vec2 parallax = mouseNdc * 40.0;
                        pos.xy += parallax * isStars;
                        
                        float dynamicSize = mix(size, size * 0.6, isSnow);

                        vec2 pointerWorld = vec2(mouseNdc.x * 900.0, mouseNdc.y * 600.0);
                        vec2 delta = pos.xy - pointerWorld;
                        float dist = length(delta) + 0.0001;

                        float snowTime = uTime * (0.3 + speed * 0.35);
                        float swayX = sin(snowTime + randomVal * 6.2831) * 30.0;
                        float swayY = sin(snowTime * 0.7 + randomVal * 12.0) * 18.0;
                        float flutter = sin(snowTime * 1.7 + randomVal * 24.0) * 12.0;
                        float snowFall = mod(pos.y + uTime * (15.0 + speed * 35.0), 1400.0) - 700.0;
                        pos.x += (swayX + swayY) * isSnow;
                        pos.y = mix(pos.y, snowFall, isSnow);
                        pos.z += flutter * isSnow;
                        float repel = (1.0 - smoothstep(50.0, 320.0, dist)) * uInteractionIntensity;
                        vec2 repelDir = delta / dist;
                        pos.xy += repelDir * repel * 60.0 * isSnow;

                        float loopLen = 2000.0;
                        float flow = fract((uTime * (80.0 + speed * 50.0) + position.x + randomVal * loopLen) / loopLen);
                        float flowX = mix(-loopLen * 0.5, loopLen * 0.5, flow);
                        pos.x = mix(pos.x, flowX, isWind);
                        pos.y += sin(uTime * 6.0 + randomVal * 30.0) * 90.0 * isWind;
                        pos.z += sin(uTime * 4.0 + randomVal * 48.0) * 70.0 * isWind;
                        vec2 vortexDir = vec2(-delta.y, delta.x) / dist;
                        float vortexWeight = (1.0 - smoothstep(0.0, 500.0, dist)) * uInteractionIntensity;
                        pos.xy += vortexDir * vortexWeight * 140.0 * isWind;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        float perspectiveSize = dynamicSize * (300.0 / -mvPosition.z);
                        gl_PointSize = clamp(perspectiveSize, 1.0, 60.0);

                        vRandom = randomVal;
                        vStarMask = isStars;
                        vSnowMask = isSnow;
                        vWindMask = isWind;
                        vSpinAngle = spinPhase + uTime * (0.4 + speed * 0.3);
                        vSnowFade = pow(1.0 - clamp(length(pos.xy - pointerWorld) / 900.0, 0.0, 1.0), 1.5);
                    }
                `;
            }

            fragmentShader() {
                return `
                    precision highp float;
                    uniform float uTime;
                    varying float vRandom;
                    varying float vStarMask;
                    varying float vSnowMask;
                    varying float vWindMask;
                    varying float vSpinAngle;
                    varying float vSnowFade;

                    vec2 rotateCoord(vec2 coord, float angle) {
                        float s = sin(angle);
                        float c = cos(angle);
                        mat2 rot = mat2(c, -s, s, c);
                        return rot * (coord - 0.5) + 0.5;
                    }

                    void main() {
                        vec2 coord = gl_PointCoord;
                        float starRadius = length(coord - 0.5);
                        float starAlpha = smoothstep(0.5, 0.0, starRadius);
                        float twinkle = 0.6 + 0.4 * sin(uTime * 2.0 + vRandom * 10.0);

                        vec2 snowCoord = rotateCoord(coord, vSpinAngle);
                        float snowMask = smoothstep(0.45, 0.0, length(snowCoord - 0.5));
                        float snowAlpha = snowMask * (0.4 + 0.6 * vSnowFade);

                        float windAlpha = smoothstep(0.6, 0.2, starRadius);
                        vec3 starColor = vec3(0.78, 0.83, 1.0);
                        vec3 snowColor = mix(vec3(0.92, 0.95, 1.0), vec3(0.82, 0.88, 1.0), vRandom);
                        vec3 windColor = vec3(0.65, 0.72, 0.85);

                        vec3 color = vec3(0.0);
                        float alpha = 0.0;

                        color += starColor * vStarMask * twinkle;
                        alpha += starAlpha * vStarMask * twinkle;

                        color += snowColor * vSnowMask;
                        alpha += snowAlpha * vSnowMask;

                        color += windColor * vWindMask;
                        alpha += windAlpha * vWindMask;

                        if (alpha <= 0.01) discard;
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
            }

            update(time, mode, pointer, viewport, intensity) {
                this.uniforms.uTime.value = time;
                this.uniforms.uMode.value = mode;
                this.uniforms.uPointer.value.copy(pointer);
                this.uniforms.uViewport.value.copy(viewport);
                this.uniforms.uInteractionIntensity.value = intensity;
            }

            resize(width, height) {
                this.uniforms.uViewport.value.set(width, height);
            }
        }

        class RainEngine {
            constructor(scene) {
                this.scene = scene;
                this.count = RAIN_COUNT;
                this.uniforms = {
                    uTime: { value: 0 },
                    uPointer: { value: new THREE.Vector2(0.5, 0.5) },
                    uViewport: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uGlobalOpacity: { value: 0 }
                };
                this.material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: this.vertexShader(),
                    fragmentShader: this.fragmentShader(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                });
                this.mesh = this.createMesh();
                this.scene.add(this.mesh);
            }

            createMesh() {
                const baseGeometry = new THREE.PlaneGeometry(3, 60);
                const geometry = baseGeometry.toNonIndexed();
                const instancePos = new Float32Array(this.count * 3);
                const instanceSpeed = new Float32Array(this.count);
                const instanceHeight = new Float32Array(this.count);

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    instancePos[i3] = (Math.random() - 0.5) * 1400;
                    instancePos[i3 + 1] = Math.random() * 1200;
                    instancePos[i3 + 2] = (Math.random() - 0.5) * 400;
                    instanceSpeed[i] = 0.6 + Math.random() * 0.6;
                    instanceHeight[i] = 0.7 + Math.random() * 0.6;
                }

                geometry.setAttribute('instancePos', new THREE.InstancedBufferAttribute(instancePos, 3));
                geometry.setAttribute('instanceSpeed', new THREE.InstancedBufferAttribute(instanceSpeed, 1));
                geometry.setAttribute('instanceHeight', new THREE.InstancedBufferAttribute(instanceHeight, 1));
                geometry.instanceCount = this.count;

                const mesh = new THREE.Mesh(geometry, this.material);
                mesh.frustumCulled = false;
                return mesh;
            }

            vertexShader() {
                return `
                    attribute vec3 instancePos;
                    attribute float instanceSpeed;
                    attribute float instanceHeight;
                    uniform float uTime;
                    uniform vec2 uPointer;
                    uniform vec2 uViewport;
                    varying float vFade;

                    void main() {
                        float fallCycle = mod(uTime * instanceSpeed * 120.0 + instancePos.y, 1200.0);
                        float yPos = 600.0 - fallCycle;
                        float windSway = sin(uTime * 0.4 + instancePos.z * 0.3) * 15.0;
                        float xDrift = -fallCycle * 0.12 + windSway;

                        vec2 rainCenter = vec2(instancePos.x + xDrift, yPos);
                        vec2 mouseNdc = (uPointer / uViewport) * 2.0 - 1.0;
                        vec2 pointer = vec2(mouseNdc.x * 900.0, mouseNdc.y * 600.0);
                        vec2 delta = rainCenter - pointer;
                        float dist = length(delta) + 0.0001;
                        float repel = smoothstep(150.0, 50.0, dist);
                        rainCenter += (delta / dist) * repel * 40.0;

                        vec3 transformed = vec3(rainCenter, instancePos.z);
                        vec3 scaledVertex = vec3(position.x, position.y * instanceHeight, position.z);
                        vec4 mvPosition = modelViewMatrix * vec4(transformed + scaledVertex, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        vFade = pow((1.0 - (position.y / 60.0 + 0.5)), 1.8);
                    }
                `;
            }

            fragmentShader() {
                return `
                    precision highp float;
                    uniform float uGlobalOpacity;
                    varying float vFade;
                    void main() {
                        vec3 color = vec3(0.7, 0.82, 0.98);
                        float alpha = vFade * uGlobalOpacity * 0.85;
                        if (alpha <= 0.01) discard;
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
            }

            update(time, pointer, viewport, opacity) {
                this.uniforms.uTime.value = time;
                this.uniforms.uPointer.value.copy(pointer);
                this.uniforms.uViewport.value.copy(viewport);
                this.uniforms.uGlobalOpacity.value = opacity;
            }

            resize(width, height) {
                this.uniforms.uViewport.value.set(width, height);
            }
        }

        class MeteorSystem {
            constructor(scene) {
                this.scene = scene;
                this.active = [];
                this.material = new THREE.LineBasicMaterial({
                    color: new THREE.Color(0.9, 0.9, 1.0),
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
            }

            spawn() {
                const length = 80 + Math.random() * 60;
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(-length, -length * 0.3, 0)
                ]);
                const line = new THREE.Line(geometry, this.material.clone());
                const angle = Math.random() * Math.PI * 2;
                const radius = 600 + Math.random() * 400;
                line.position.set(Math.cos(angle) * radius, 200 + Math.random() * 200, -200 + Math.random() * 200);
                line.userData.birth = performance.now();
                line.userData.duration = 600;
                this.scene.add(line);
                this.active.push(line);
            }

            update(delta, mode) {
                const now = performance.now();
                if (mode < 0.5 && Math.random() < delta * 0.25) {
                    this.spawn();
                }
                this.active = this.active.filter((meteor) => {
                    const elapsed = now - meteor.userData.birth;
                    const life = elapsed / meteor.userData.duration;
                    if (life >= 1) {
                        this.scene.remove(meteor);
                        meteor.geometry.dispose();
                        meteor.material.dispose();
                        return false;
                    }
                    meteor.material.opacity = 0.4 * (1 - life);
                    meteor.position.x -= 400 * delta;
                    meteor.position.y -= 260 * delta;
                    return true;
                });
            }
        }

        let renderer, scene, camera, pointsEngine, rainEngine, meteorSystem, clock;
        const pointer = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
        const pointerTarget = pointer.clone();
        const viewport = new THREE.Vector2(window.innerWidth, window.innerHeight);
        let pointerActive = false;

        const modeState = {
            current: MODE_STAR,
            previous: MODE_STAR,
            target: MODE_STAR,
            start: 0
        };

        function lerpMode(time) {
            const elapsed = Math.min(1, (time - modeState.start) / MODE_LERP_MS);
            const eased = THREE.MathUtils.smoothstep(elapsed, 0, 1);
            const display = THREE.MathUtils.lerp(modeState.previous, modeState.target, eased);
            if (elapsed >= 1) {
                modeState.current = modeState.target;
                modeState.previous = modeState.target;
            }
            return display;
        }

        function setWeatherMode(mode) {
            if (mode === modeState.target) return;
            modeState.previous = modeState.current;
            modeState.target = mode;
            modeState.start = performance.now();
            
            const data = weatherData[mode];
            const tempEl = document.getElementById('temp-value');
            const descEl = document.getElementById('weather-desc').querySelector('span');
            const poetryEl = document.getElementById('poetry-text');
            
            tempEl.style.opacity = '0';
            descEl.style.opacity = '0';
            poetryEl.style.opacity = '0';
            
            setTimeout(() => {
                tempEl.textContent = data.temp;
                descEl.textContent = data.desc;
                poetryEl.textContent = data.poetry;
                tempEl.style.transition = 'opacity 300ms';
                descEl.style.transition = 'opacity 300ms';
                poetryEl.style.transition = 'opacity 300ms';
                tempEl.style.opacity = '1';
                descEl.style.opacity = '1';
                poetryEl.style.opacity = '1';
            }, 300);
        }

        function updatePointer(delta) {
            pointer.lerp(pointerTarget, 1 - Math.exp(-delta / POINTER_SMOOTH));
            if (!pointerActive) {
                pointerTarget.lerp(new THREE.Vector2(viewport.x / 2, viewport.y / 2), 0.5);
            }
        }

        function initParticles() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 0, 1400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('three-canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            pointsEngine = new PointsEngine(scene, camera);
            rainEngine = new RainEngine(scene);
            meteorSystem = new MeteorSystem(scene);
            clock = new THREE.Clock();

            window.addEventListener('pointermove', (e) => {
                pointerTarget.set(e.clientX, e.clientY);
                pointerActive = true;
            });
            window.addEventListener('pointerleave', () => {
                pointerTarget.set(window.innerWidth / 2, window.innerHeight / 2);
                pointerActive = false;
            });
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                viewport.set(width, height);
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                pointsEngine.resize(width, height);
                rainEngine.resize(width, height);
                createLanterns();
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.elapsedTime;
            updatePointer(delta);

            const displayMode = lerpMode(performance.now());
            pointsEngine.update(elapsed, displayMode, pointer, viewport, pointerActive ? 1 : 0.4);

            const rainTarget = modeState.target === MODE_RAIN ? 1 : 0;
            const rainPrev = modeState.previous === MODE_RAIN ? 1 : 0;
            const rainLerp = (performance.now() - modeState.start) / MODE_LERP_MS;
            const rainWeight = THREE.MathUtils.lerp(rainPrev, rainTarget, THREE.MathUtils.smoothstep(Math.min(1, rainLerp), 0, 1));

            rainEngine.update(elapsed, pointer, viewport, rainWeight);
            meteorSystem.update(delta, displayMode);

            renderer.render(scene, camera);
        }

        function createLanterns() {
            const container = document.getElementById('lantern-container');
            const isMobileLantern = window.matchMedia("(max-width: 768px)").matches;
            const lanternCount = isMobileLantern ? Math.floor(Math.random() * 3 + 5) : Math.floor(Math.random() * 6 + 15);

            container.innerHTML = '';
            const svgNS = "http://www.w3.org/2000/svg";

            for (let i = 0; i < lanternCount; i++) {
                const lantern = document.createElement('div');
                lantern.className = 'lantern';

                const size = Math.random() * 20 + 25;
                const left = Math.random() * 30 + 65;
                const top = Math.random() * 80 + 10;
                const hue = Math.random() * 18 + 38;
                const floatDuration = Math.random() * 4 + 5;
                const glowDuration = Math.random() * 2 + 4;

                lantern.style.width = `${size}px`;
                lantern.style.height = `${size * 1.3}px`;
                lantern.style.left = `${left}%`;
                lantern.style.top = `${top}%`;
                lantern.style.animationDuration = `${floatDuration}s, ${glowDuration}s`;
                lantern.style.animationDelay = `-${(Math.random() * floatDuration).toFixed(2)}s, -${(Math.random() * glowDuration).toFixed(2)}s`;

                if (isMobileLantern && i >= 6) lantern.classList.add('hide-on-mobile');

                const svg = document.createElementNS(svgNS, "svg");
                svg.setAttribute('viewBox', '0 0 30 40');
                svg.style.width = '100%';
                svg.style.height = '100%';

                const defs = document.createElementNS(svgNS, 'defs');
                const radialGradient = document.createElementNS(svgNS, 'radialGradient');
                const gradientId = `grad${i}`;
                radialGradient.setAttribute('id', gradientId);

                const stops = [
                    { offset: '0%', color: `hsla(${hue}, 100%, 80%, 0.9)` },
                    { offset: '50%', color: `hsla(${hue}, 90%, 60%, 0.7)` },
                    { offset: '100%', color: `hsla(${hue}, 80%, 50%, 0)` }
                ];

                stops.forEach(s => {
                    const stop = document.createElementNS(svgNS, 'stop');
                    stop.setAttribute('offset', s.offset);
                    stop.setAttribute('stop-color', s.color);
                    radialGradient.appendChild(stop);
                });

                defs.appendChild(radialGradient);
                svg.appendChild(defs);

                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('d', 'M10 10 L20 10 L22 25 L8 25 Z');
                path.setAttribute('fill', `hsla(${hue}, 90%, 70%, ${Math.random() * 0.3 + 0.6})`);
                svg.appendChild(path);

                const ellipseOuter = document.createElementNS(svgNS, 'ellipse');
                ellipseOuter.setAttribute('cx', '15');
                ellipseOuter.setAttribute('cy', '25');
                ellipseOuter.setAttribute('rx', '8');
                ellipseOuter.setAttribute('ry', '5');
                ellipseOuter.setAttribute('fill', `url(#${gradientId})`);
                svg.appendChild(ellipseOuter);

                const ellipseInner = document.createElementNS(svgNS, 'ellipse');
                ellipseInner.setAttribute('cx', '15');
                ellipseInner.setAttribute('cy', '25');
                ellipseInner.setAttribute('rx', '6');
                ellipseInner.setAttribute('ry', '3.5');
                ellipseInner.setAttribute('fill', `hsla(${hue}, 100%, 90%, 0.8)`);
                svg.appendChild(ellipseInner);

                lantern.appendChild(svg);
                container.appendChild(lantern);
            }
        }

        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            document.getElementById('clock-time').textContent = `${hours}:${minutes}`;
            document.getElementById('clock-date').textContent = `${year}年${month}月${day}日`;
        }

        document.querySelectorAll('[data-mode]').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                setWeatherMode(Number(button.dataset.mode));
            });
        });

        createLanterns();
        updateClock();
        setInterval(updateClock, 60000);
        initParticles();
    </script>
</body>
</html>
